package fuzs.puzzleslib.config;

import net.minecraftforge.common.ForgeConfigSpec;
import net.minecraftforge.fml.config.ModConfig;

import java.nio.file.Paths;
import java.util.function.Consumer;
import java.util.function.Supplier;

/**
 * a config holder holds two separate configs for both logical server and logical client
 * one or both types may not be present, depending on mod requirements and physical side
 * @param <C> client config type
 * @param <S> server config type
 */
public interface ConfigHolder<C extends AbstractConfig, S extends AbstractConfig> {

    /**
     * @return client config from this holder, possibly null
     */
    C client();

    /**
     * @return server config from this holder, possibly null
     */
    S server();

    /**
     * @param callback callback for this client config
     */
    void addClientCallback(Runnable callback);

    /**
     * @param callback callback for this server config
     */
    void addServerCallback(Runnable callback);

    /**
     * @param modId mod id this config belongs to
     * @return config name
     */
    static String simpleName(String modId) {
        return String.format("%s.toml", modId);
    }

    /**
     * @param type type of config
     * @param modId mod id this config belongs to
     * @return config name as when generated by Forge
     */
    static String defaultName(String modId, ModConfig.Type type) {
        return String.format("%s-%s.toml", modId, type.extension());
    }

    /**
     * @param configDir dir to move config to
     * @param fileName config file name
     * @return path to config in dir
     */
    static String moveToDir(String configDir, String fileName) {
        return Paths.get(configDir, fileName).toString();
    }

    /**
     * @param client client config factory
     * @param server server config factory
     * @param <C> client config type
     * @param <S> server config type
     * @return a config holder which only holds both a client config and a server config
     */
    static <C extends AbstractConfig, S extends AbstractConfig> ConfigHolderImpl<C, S> of(Supplier<C> client, Supplier<S> server) {
        return new ConfigHolderImpl<>(client, server);
    }

    /**
     * @param client client config factory
     * @param <C> client config type
     * @return a config holder which only holds a client config
     */
    static <C extends AbstractConfig> ConfigHolderImpl<C, AbstractConfig> client(Supplier<C> client) {
        return new ConfigHolderImpl<>(client, () -> null);
    }

    /**
     * @param server server config factory
     * @param <S> server config type
     * @return a config holder which only holds a server config
     */
    static <S extends AbstractConfig> ConfigHolderImpl<AbstractConfig, S> server(Supplier<S> server) {
        return new ConfigHolderImpl<>(() -> null, server);
    }

    /**
     * callback interface for saving config values upon config reload
     */
    @FunctionalInterface
    interface ConfigCallback {

        /**
         * @param entry source config value object
         * @param save action to perform when value changes (is reloaded)
         * @param <T> type for value
         */
        <T> void accept(ForgeConfigSpec.ConfigValue<T> entry, Consumer<T> save);
    }
}
